# TestingRobotChallenge
TestingRobotChallenge is a Web application designed to support the learning of software testing through gamification, where players compete against preconfigured tester opponents called Robots. The goal for each player is to write JUnit4 test code for a given Java class, aiming to outperform — or at least match — the effectiveness of the test cases automatically generated by the opponents.
Successful players are awarded scores and achievements for each challenge they win. A leaderboard tracks player performance, showing the
number of challenges won and the total score earned. Top-performing players are eligible for rewards.

Learning Objectives of the Web App: 
- Motivate students to practice software testing exploiting the gamification
- Learn how to write effective unit tests with a focus on code coverage
- Allow students to acquire familiarity with existing test automation tools.

TestingRobotChallenge is realized in the context of the ENACTEST Erasmus+ project (https://enactest-project.eu/) financed by the European Commission (Project Number 101055874) and by the GATT project financed by the University of Naples Federico II.

## Key Features
- Role-based access: users can register either as administrators or players. Administrators — typically instructors — can upload new Java classes to be tested and configure opponents (called robots). Players — typically students — can then challenge these robots;
- Experience points and achievements: players earn experience points for each defeated robot, which contribute to their level progression. Completing specific challenges also unlocks achievements;
- Match history: a dedicated section allows players to review their past matches, showing which were won or lost;
- Multiple game modes: the platform currently supports two gameplay modes:
  - Practice: players can freely test their skills on a Java class without competing against a robot and without being scored.
  - Single Match: players compete against a robot by trying to match or exceed its instruction-level bytecode coverage. Matches are time-limited, with the duration chosen by the player before starting.

## System Design and Implementation
The platform is implemented as a browser-accessible web application based on a microservices architecture. Each component is containerized using Docker and exposes REST APIs, making the system easy to deploy, scale, and maintain.

The platform consists of the following microservices:
1. **T1**, which manages administrator-related functionalities, including class and robot management;
2. **T23**, which handles user authentication (for both administrators and players) and all related user information;
3. **T4**, which tracks the state of matches;
4. **T5**, which manages gameplay logic and the related web interfaces;
5. **T7**, which compiles the provided test code and calculates coverage metrics using **JaCoCo**;
6. **T8**, which compiles the provided test code and calculates metrics based on **EvoSuite**.


### Data Persistence
The system uses Docker volumes and containerized databases to persist data. Specifically:
1. **T23** communicates with a **MySQL** database for user authentication and for storing all data associated with them;
2. **T4** communicates with a **PostgreSQL** database to store match data;
3. **T1** communicates with a **MongoDB** database to manage the file paths of Java classes uploaded for testing and their associated opponents;
4. The shared Docker volume **VolumeT0** is used to store a copy of each Java class to be tested along with the related robots, as well as a copy of each player's compilation output, including the corresponding metrics.

### Support Services
Two standalone components complement the system:
1. **T0**, a self-contained component that can automatically generate JUnit 4 tests for a given Java class using Randoop and EvoSuite;
2. **db-backup**, a utility service that performs regular backups (as dumps) of the PostgreSQL and MySQL databases used by T23 and T4.

These services can be invoked directly from the host machine when needed.

## Requirements 
- Docker Desktop ver. 4.40.0
- Windows Subsystem for Linux (WSL) (only for Windows Installation)

## System Deployment and Installation
TestingRobotChallenge includes a suite of scripts to simplify the build and deployment process:
- `build.bat` / `build.sh`: Windows/Linux scripts to build and create Docker images for all microservices and components;
- `deploy.bat` / `deploy.sh`: Windows/Linux scripts to deploy all containers, create necessary Docker volumes and networks, and start services. Local images will be used if available; otherwise, images from DockerHub will be pulled;
- `selective_build_and_deploy.bat` / `selective_build_and_deploy.sh`: Windows/Linux scripts that allow selective build and deployment of specific microservices, mainly used during development;
- `uninstaller.bat` / `uninstaller.sh`: Windows/Linux scripts that purge all Docker containers, images, networks, and volumes on the host. Use with caution.

## How to Configure the Game
Administrators are in charge to preliminary configure the Web App by uploading the Java Classes to be tested and the Test Cases automatically generated by the Robots. 
The ClassUT directory of the repository contains some examples of Java Classes and the test cases automatically generated by several Generators, namely EVOSUITE, Randoop, and different LLMs (ChatGPT, Gemini, and Llama).

## How to Play 





