# T56 Module

The T56 module serves the player's pages and provides the game engine for running a match. It represents the main module
of the system.
The current implementation allows the player to:

1. View their player profile, including information on experience points earned and unlocked achievements;
2. Access a history of played matches;
3. Start a new match or resume an ongoing one;
4. Play a match using the provided editor.

## Module Structure Overview

The module consists of a set of packages, as shown below:

```html
com.g2
├── components
├── controllers
├── game
│   ├── GameDTO
│   ├── GameFactory
│   ├── GameModes
│   ├── Service
│   └── GameController
├── interfaces
│   └── util
├── language
├── model
│   └── dto
├── security
├── session
│   └── Exceptions
├── t5
└── util
    └── achievement
```

In detail:

1. The package `components` handles the construction of web pages based on modular components that clearly separate
   business logic from data presentation.
   Components are available in generic versions and are integrated with the Service Manager to facilitate
   interoperability between tasks.
2. The package `controllers` provides the GUI controllers, one for the player profile and the other for dashboard/start
   game views;
3. The package `game` defines the core of the service, the **game engine**. It contains all classes to manage game
   logic, concurrency and active games:
    * `GameDTO` defines the dtos for the communication client-server, such as starting the game, running the game,
      resuming the game, etc;
    * `GameFactory` contains the logic for defining and handling game modes;
    * `Service` defines the service classes invoked by the engine;
    * The class `GameController` provide the controller for the game execution API.
4. The package `interfaces` manages interactions with REST services, fully encapsulating network logic and providing a
   centralized dispatcher, the **Service Manager**, to simplify call management. Its introduction allows developers to
   easily define and add new tasks to the front-end, quickly introduce new REST calls to existing services, and define
   various ways to leverage and combine available services efficiently.
5. The package `language` provides all classes necessary for handling language switching and localization.
6. The package `model` contains the core domain model of the module. The subpackage `dto` holds all the Data Transfer
   Objects used for client and API interactions.
7. The package `session` handles the redis session;
8. The package `t5` contains teh starting point of the application and the logic to handle the language change
9. The package `util.achievements` defines the achievements unlockable by the player.

A more detailed guide regarding the implementation of packages `components`, `interfaces` and `game` is available in the
wiki.

## Authentication and Security

The `security` package handles the security related to teh module. Its structure is the following:

```html
security
├── AuthTokenFilter
├── FilterConfig
└── JwtRequestContext
```

The `JwtRequestContext` class is a utility designed to store the JWT received in the user's request. This token is then
used in all subsequent internal
communications between modules, ensuring that these communications are properly authenticated.

The `AuthTokenFilter` is a filter responsible for verifying whether the incoming HTTP request is authenticated. It
checks for the presence of a JWT
in the COOKIES section of the request and validates it. The validation is performed by communicating with T23.

If the JWT is valid, the filter allows the request to proceed, and the module can start processing it. The JWT is stored
by `JwtRequestContext` as said above.

If the JWT is missing or invalid (e.g., expired), the filter checks for the presence of a Refresh Token. If a Refresh
Token is found, it is sent to T23 for validation.
If the Refresh Token is successfully validated, T23 issues a new JWT and, at the same time, authenticates the request.
The new JWT is then added by T1 to
the response sent back to the client, ensuring the old token is updated.

Before processing the request, the filter performs one final check on the validated JWT: it verifies the role associated
with the token.
Although T1 is primarily used by administrators, it may also receive internal requests from T5, which is associated with
player roles.

The filter verifies the role linked to the JWT — again through T23 — and compares it with the requested URL.
If the URL is permitted for the given role, the request is allowed to proceed. Otherwise, it is rejected.

The filter is enabled by `FilterConfig` for all the incoming HTTP requests.

## Defining and Unlocking Achievements

The achievement supported by the system can be categorized in:

* Achievements linked to the game mode played, which are evaluated on the scores achieved during the game;
* Achievements related to general metrics as total number of games played, number of robot beaten, etc, which are
  evaluated the stored scores of the players.

For simplicity, we'll call the first type *game mode achievements* and the second *global achievements*.

The current version of the software implements a hardcoded solution to define and unlocking achievements, with code
scattered between multiple packages and classes:

1. Each *global achievement* is implemented as an independent class in `util.achievements`;
2. Each *game mode achievement* implementation is described in the related game mode which provides it, such as
   `PartitaSingola` (in `game.GameModes` package)
3. The verification if an achievement is unlocked is defined in the class `AchievementService`.
4. The verification is invoked by the game engine in `GameService` class (`game.Service` package) in the methods
   `handleGlobalAchievementUnlocked()`
   and `handleGameModeAchievementsUnlocked()`.

Although less flexible than other solutions, this implementation allows to define specific achievements each game modes.

### Game Mode Achievements

Each game mode can define zero, one or more *game mode achievements*. By default, each game mode provides zero
achievements.
To add a new achievement for the game mode, the related class must:

1. Define the necessary methods to verify the intended conditions. Each condition must evaluate the state of the
   `CompileResult`
   of the user against the one of the opponent of the game. The example below verify if the user has beaten the robot in
   the metrics "Jacoco Instruction Coverage" and "Evosuite Weak Mutation Coverage";
   ```java
   private Boolean beatOnJacocoInstructionCoverage(CompileResult user, CompileResult robot) {
     return user.getInstructionCoverage().getCovered() > robot.getInstructionCoverage().getCovered();
   }
   
   private Boolean beatOnEvosuiteWeakMutationCoverage(CompileResult user, CompileResult robot) {
     return user.getEvosuiteWeakMutation().getCovered() > robot.getEvosuiteWeakMutation().getCovered();
   }
   ```

2. Override the method `gameModeAchievements()` provided in the super class `GameLogic` to add the new achievement to
   the
   ones available for the game mode. The achievements are stored as a map, where:
    * The key represents the name of the achievement;
    * The value represent logic composition of the methods defined in step 1, as a `BiFunction` object. The type
      `BiFunction`
      allows to define an achievement as a function with two input (both of type `CompileResult`) and one output (of
      type `Boolean`)
      which will be executed by the `AchievementService`.

   An example is shown below:
   ```java
   @Override
    public Map<String, BiFunction<CompileResult, CompileResult, Boolean>> gameModeAchievements() {
        Map<String, BiFunction<CompileResult, CompileResult, Boolean>> verifyBeaten = new HashMap<>();
        verifyBeaten.put("instructions", this::beatOnJacocoInstructionCoverage);
        verifyBeaten.put("instructionsAndWeakMutation", (user, robot) ->
                beatOnJacocoInstructionCoverage(user, robot) && beatOnEvosuiteWeakMutationCoverage(user, robot));

        return verifyBeaten;
    }
   ```
   Here, the achievement `instructions` is unlocked if the user has beaten the robot in the coverage of the "Jacoco
   Instructions"
   (`beatOnJacocoInstructionCoverage()`), while the achievement `instructionsAndWeakMutation` is unlocked if the user
   has beaten the robot
   both the metrics evaluated by the two methods defined.

### Global Achievements

*Global achievements* are defined by appropriate classes in the system. Similarly to the game mode achievements
implementation, each
class is composed by:

1. One or more methods to verify certain conditions;
   ```java
   private static Boolean beatAllRobotForOneClassUT(Map<String, List<GameProgressDTO>> gameProgressesByClass, Map<String, List<OpponentSummary>> availableRobotsByClass) {
           for (String classUT : gameProgressesByClass.keySet()) {
               if (availableRobotsByClass.containsKey(classUT) && gameProgressesByClass.get(classUT).size() == availableRobotsByClass.get(classUT).size())
                   return true;
           }
           return false;
       }
   
       private static Boolean beatAllRobotForTwoClassUT(Map<String, List<GameProgressDTO>> gameProgressesByClass, Map<String, List<OpponentSummary>> availableRobotsByClass) {
           int beaten = 0;
           for (String classUT : gameProgressesByClass.keySet()) {
               if (availableRobotsByClass.containsKey(classUT) && gameProgressesByClass.get(classUT).size() == availableRobotsByClass.get(classUT).size())
                   beaten++;
           }
           return beaten >= 2;
       }
   ```

2. A method that returns the achievement as map *<achievement name, logic composition of one or mode condition>*:
   ```java
   public static Map<String, BiFunction<Map<String, List<GameProgressDTO>>, Map<String, List<OpponentSummary>>, Boolean>> getAchievementFunctions() {
           Map<String, BiFunction<Map<String, List<GameProgressDTO>>, Map<String, List<OpponentSummary>>, Boolean>> verifyBeaten = new HashMap<>();
   
           verifyBeaten.put("allBeatenOneClass", NumberAllRobotForClassBeaten::beatAllRobotForOneClassUT);
           verifyBeaten.put("allBeatenTwoClass", NumberAllRobotForClassBeaten::beatAllRobotForTwoClassUT);
   
           return verifyBeaten;
       }
   ```
   Similar to the *game mode achievements* solution, this implementation evaluate an achievement with a `Funtion`
   object.
   The current version doesn't provide a common interface for the classes, allowing flexibility regarding the type of
   data passed in
   input (`OpponentSummary`, `GameProgressDTO`, ...) and the arity of the function (`Function`, `BiFunction`, ...).

### Achievements Evaluation

All achievement evaluations are handled by the `AchievementService` class. Each achievement category must be processed
by
a dedicated method, meaning that every achievement mapping — with its own `Function` type and input parameters —
requires a specific evaluation method.
Each method must return a `Set` of the names of the achievements unlocked.

### Achievements Evaluation in Game Flow

Achievement evaluation is invoked by the game engine `GameService` class. In details:

1. *Game mode achievements* are evaluated on the coverage score of every compilation of the user, before returning the
   compilation result to the client;
2. *Global achievements* are evaluated at the end of the game, considering the player's stats updated with the result of
   the current game.

## Experience points

At the end of a game, the player may earn experience points if:

* They defeated their opponent;
* It is the first time they have defeated that specific opponent.

The amount of experience gained depends on the opponent’s difficulty: 1 point for `Easy`, 2 points for `Medium`, and 3
points for `Hard`.

## Logging of Player Compilations

Each player compilation, each one corresponding to a turn generally, must be stored in the docker volume `VolumeT0`. A
more detailed
description of the structure of the volume is available in the wiki.
For each compilation the system must store:

1. The test written by the player;
2. The metrics computed by JaCoCo and Evosuite.

The compilation is saved in the `StudentTest` directory with the following patter:

```html
player_id/game_mode/compilation_timestamp/game_id/round_number/turn_number/
├── coverage
│   └── statistics.csv // coveragetot.xml
└── project
    └── src
        ├── java
        │   └── main
        │       └── ClassUT.java
        └── test
            └── main
                └── PlayerTest.java
```

Currently, JaCoCo metrics are computed after every compilation, whereas EvoSuite metrics are computed only when the
player
chooses to end the game. Therefore, for a single game, there will be one or more entries corresponding to each
compilation,
containing only the JaCoCo metrics. A final entry, corresponding to the end of the game, will include the same player
test as
the last compilation entry, but with metrics computed by EvoSuite.





